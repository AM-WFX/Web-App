<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Ultimate CSS Selector Lab</title>
    <link rel="stylesheet" href="styles.css"> 
    
    <style>
        /* --- General Layout and Formatting --- */
        .container {
            max-width: 1300px; 
            margin: 0 auto;
        }

        .main-content {
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* --- Side-by-Side Challenge Layout --- */
        #all-challenges {
            display: flex;
            flex-wrap: wrap; 
            gap: 20px; 
            justify-content: flex-start;
        }
        
        .challenge-container {
            width: calc(50% - 10px); 
            min-width: 400px; 
            
            margin-top: 10px; 
            padding: 20px;
            border: 1px solid #c9e6ff;
            border-radius: 6px;
            margin-bottom: 20px; 
            background-color: #f6faff;
        }
        
        /* --- VISUAL UNIFORMITY RULES (CORE FIX) --- */
        
        .challenge-target-area * {
            box-sizing: border-box; 
        }

        .challenge-target-area button,
        .challenge-target-area input,
        .challenge-target-area li,
        .challenge-target-area p,
        .challenge-target-area div,
        .challenge-target-area label,
        .challenge-target-area a,
        .challenge-target-area h2,
        .challenge-target-area h3,
        .challenge-target-area span {
            border: 1px solid #ccc !important; 
            background-color: #fcfcfc !important; 
            color: #333 !important;
            font-family: inherit !important;
            font-size: 0.9em !important;
            line-height: 1.2 !important;
            padding: 8px 12px !important;
            margin: 6px !important;
            border-radius: 4px !important;
            display: inline-block !important; 
            text-align: left !important;
        }

        .challenge-target-area button {
            background-color: #eee !important; 
            border-color: #ccc !important;
            font-weight: normal !important;
            cursor: default !important;
        }
        
        .challenge-target-area input[type="text"],
        .challenge-target-area input[type="checkbox"] {
            border: 1px solid #ccc !important;
            width: auto;
        }
        
        .challenge-target-area ul, 
        .challenge-target-area ol, 
        .challenge-target-area div#settings-modal {
            border: 2px dashed #999 !important; 
            padding: 10px !important;
            margin: 10px auto !important;
            background-color: #f0f0f0 !important;
            display: block !important;
            text-align: left !important;
            max-width: 90%;
            width: auto;
        }
        .challenge-target-area li, .challenge-target-area label {
            display: list-item !important; 
            list-style-type: none; 
            border: 1px solid #ddd !important;
            background-color: #fff !important;
        }
        .challenge-target-area p {
            line-height: 1.5 !important;
        }


        /* The Visual Target Highlight (Applied by JS) */
        .target-highlight {
            border: 2px solid #cc0000 !important;
            background-color: #fffac9 !important;
            padding: 7px 11px !important; 
            margin: 5px !important;
        }
        
        /* --- UI and Feedback Elements --- */

        .challenge-header h3 {
            margin: 0;
            color: #1a5c9a;
        }

        .challenge-ui {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .challenge-ui input[type="text"] {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
            font-size: 1em;
        }

        .challenge-ui button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            white-space: nowrap;
        }
        
        .success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .info { background-color: #e2f4fb; color: #0c5460; border: 1px solid #bee5eb; }

        .accordion {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #eee;
            color: #444;
            cursor: pointer;
            padding: 10px;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 0.9em;
            transition: 0.4s;
            margin-top: 5px;
            border-radius: 4px;
        }
        .active-accordion, .accordion:hover { background-color: #ccc; }
        .accordion::after {
            content: ' \25BC';
            color: #777;
            font-weight: bold;
            transition: 0.4s;
            transform: rotate(0deg);
        }
        .active-accordion::after { transform: rotate(-180deg); }
        .panel {
            padding: 0 18px;
            background-color: white;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
            border-left: 2px solid #007bff;
            margin-bottom: 5px;
        }
        .reveal-button {
            background-color: #ffc107;
            color: #333;
            margin-top: 10px;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <header class="navbar">
        <div class="logo">My Site</div>
        <nav>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="about.html">About</a></li>
                <li><a href="css-selectors.html" class="active">Selectors</a></li>
            </ul>
        </nav>
    </header>

    <div class="container">
        <aside class="sidebar" style="/* Layout style here */">...</aside>
        
        <main class="content main-content">
            <h1>The Ultimate CSS Selector Lab ðŸŽ¯</h1>
            <p>Your task: Write a selector that targets **only the element currently highlighted** within each challenge box. You must remove the highlight by entering the correct selector and clicking 'Validate'.</p>
            
            <div id="all-challenges">
                </div>
            
        </main>
    </div>

    <footer>
        <p>&copy; 2025 My Awesome Website</p>
    </footer>

    <script>
        // Store the state of each challenge
        const challengeStates = {};
        
        // Helper function to create a new challenge structure (used after reveal)
        function generateNewChallengeHTML(def) {
            let html;
            let newTargetSelector;
            
            // Simple structure changes for different types
            if (def.type.includes('ID Selector')) {
                html = `
                    <button id="try-one" class="btn-group">Button One</button>
                    <button id="try-two" class="btn-group new-target">Target Again</button>
                    <button id="try-three" class="btn-group">Button Three</button>
                `;
                newTargetSelector = "#try-two";
            } else if (def.type.includes('Class Selector')) {
                html = `
                    <div class="data-item">Item A</div>
                    <div class="data-item new-target">Item B (Target)</div>
                    <div class="data-item">Item C</div>
                `;
                newTargetSelector = ".new-target";
            } else if (def.type.includes('Descendant Combinator')) {
                html = `
                    <div id="project-list">
                        <p>File A</p>
                        <div class="folder">
                            <p class="new-target">File B (Target)</p>
                        </div>
                    </div>
                `;
                newTargetSelector = "#project-list p.new-target";
            } else if (def.type.includes('Child Combinator')) {
                html = `
                    <ul class="nav-menu">
                        <li>Link 1</li>
                        <li><span>Link 2 (Not Target)</span></li>
                        <li class="new-target">Link 3 (Target)</li>
                    </ul>
                `;
                newTargetSelector = "ul.nav-menu > li.new-target";
            } else {
                 // Fallback for others - simple structure swap
                html = def.baseHTML.replace(def.targetSelector.replace(/[#\.\s>+~:]/g, ''), 'new-target');
                newTargetSelector = def.correctTarget.replace(def.correctTarget.replace(/[#\.\s>+~:]/g, ''), 'new-target');
            }
            
            return { html: html, newTargetSelector: newTargetSelector };
        }

        // Definition of all challenges
        const challengeDefinitions = [
            {
                id: 1,
                prompt: "Target the Primary Login Button using its unique ID.",
                targetSelector: "#login-primary",
                type: "ID Selector",
                alternatives: [
                    { selector: "button#login-primary", explanation: "This uses the tag name and the ID. Since IDs are already unique, adding the tag name is redundant but valid. It increases specificity unnecessarily, which is often avoided in production." },
                    { selector: "*#login-primary", explanation: "This uses the universal selector (*) combined with the ID. The universal selector is low specificity, but the ID still makes this selection highly efficient and correct." }
                ],
                trivia: "The ID selector is the most powerful in terms of specificity (100 points). It should be used sparingly for major, unique page elements.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors",
                html: `
                    <button id="login-primary" class="btn btn-primary">Primary Login Button</button>
                    <button id="login-secondary" class="btn btn-secondary">Secondary Button</button>
                `
            },
            {
                id: 2,
                prompt: "Target the item marked Urgent using its class.",
                targetSelector: ".task-urgent",
                type: "Class Selector",
                alternatives: [
                    { selector: "li.task-urgent", explanation: "This is a great technique: combining the tag name (li) with the class. It increases specificity slightly and clearly scopes the selection to only list items, improving readability." },
                    { selector: ".task-urgent.list-item", explanation: "This chains two class selectors together. This is useful if you want to ensure an element has *both* classes. It also increases specificity (20 points) which can be helpful if you need to override other styles." }
                ],
                trivia: "Class selectors contribute 10 points to specificity. You can chain multiple classes without a space, like `.classA.classB`.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors",
                html: `
                    <ul>
                        <li class="list-item task-default">Normal Item</li>
                        <li class="list-item task-urgent">Urgent Item</li>
                        <li class="list-item task-default">Another Normal Item</li>
                    </ul>
                `
            },
            {
                id: 3,
                prompt: "Target the Save button that is contained *anywhere* inside the #settings-modal.",
                targetSelector: "#settings-modal .btn-save",
                type: "Descendant Combinator",
                alternatives: [
                    { selector: "#settings-modal button.btn-save", explanation: "This is highly specific. It combines the ID of the container, the tag name, and the class name. This clearly states that the selector should target a button with the class `.btn-save` inside the ID `#settings-modal`." },
                    { selector: "div#settings-modal button.btn-save", explanation: "This is the most explicit form, using the tag name for the container (div) as well as its ID. It makes the selector very rigid but ensures zero ambiguity." }
                ],
                trivia: "A single space is the Descendant Combinator. It selects elements nested at *any* depth, making it the most flexible but potentially the least performant of the combinators.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/Descendant_combinator",
                html: `
                    <div id="settings-modal" style="padding: 10px; border: 1px solid #ccc;">
                        <button class="btn-cancel">Cancel</button>
                        <div class="footer">
                            <button class="btn-save">Save</button>
                        </div>
                    </div>
                `
            },
            {
                id: 4,
                prompt: "Target the Title text that is a direct child of the .card-header.",
                targetSelector: ".card-header > h2",
                type: "Child Combinator",
                alternatives: [
                    { selector: ".card-header>h2", explanation: "This is identical to the primary answer; whitespace around the '>' operator is optional and doesn't affect selection, though many prefer spaces for readability." },
                    { selector: ".card > .card-header > h2", explanation: "This chains multiple Child Combinators, ensuring that the selection only occurs if `.card-header` is a direct child of `.card` AND `h2` is a direct child of `.card-header`." }
                ],
                trivia: "The Child Combinator (`>`) ensures the relationship is direct (one level deep). This makes the CSS rule more robust against future changes in nested markup.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/Child_combinator",
                html: `
                    <div class="card" style="border: 1px solid #ccc; padding: 10px;">
                        <div class="card-header">
                            <h2>Card Title</h2>
                            <span>
                                <h2>Nested Title (Not Target)</h2>
                            </span>
                        </div>
                        <p>Card Body</p>
                    </div>
                `
            },
            {
                id: 5,
                prompt: "Target the Second Item that immediately follows the element with the class .first-element.",
                targetSelector: ".first-element + li",
                type: "Adjacent Sibling Combinator",
                alternatives: [
                    { selector: "li.first-element + li.list-item", explanation: "A highly specific version. It requires that both the preceding element and the target element are list items (li) and have their respective classes, ensuring precision." },
                    { selector: ".first-element + *", explanation: "Uses the universal selector (`+ *`) to select the immediate sibling, regardless of its tag name. Useful if the structure might change from `li` to `div` but remain a sibling." }
                ],
                trivia: "The Adjacent Sibling Combinator (`+`) only selects the *one* element that immediately follows the first selector. It's great for applying spacing after a specific element.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/Adjacent_sibling_combinator",
                html: `
                    <ul>
                        <li class="list-item">Zero Item</li>
                        <li class="list-item first-element">First Item</li>
                        <li class="list-item second-element">Second Item</li>
                        <li class="list-item">Third Item</li>
                    </ul>
                `
            },
            {
                id: 6,
                prompt: "Target the Comments button, which appears somewhere after the h3 element.",
                targetSelector: "h3 ~ button.comments",
                type: "General Sibling Combinator",
                alternatives: [
                    { selector: "h3 ~ .comments", explanation: "Less specific than the one provided. It selects any element with the class `.comments` that follows an `h3` in the same parent. This is correct but risks selecting a non-button element." },
                    { selector: "button.like ~ button.comments", explanation: "This targets the Comments button based on a different preceding sibling, the Like button. It demonstrates the flexibility of the General Sibling Combinator." }
                ],
                trivia: "The General Sibling Combinator (`~`) selects all siblings that follow the first selector. Unlike the Adjacent Sibling (`+`), it can skip over non-matching siblings.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/General_sibling_combinator",
                html: `
                    <button class="share">Share</button>
                    <h3>Post Title</h3>
                    <p>Post content...</p>
                    <button class="like">Like</button>
                    <button class="comments">Comments</button>
                `
            },
            {
                id: 7,
                prompt: "Target the input field whose name attribute contains the word 'user'.",
                targetSelector: "input[name*='user']",
                type: "Attribute Selector (Substring Match)",
                alternatives: [
                    { selector: "*[name*='user']", explanation: "Uses the universal selector (*). This selects any element, regardless of tag, that has a `name` attribute containing 'user'. This is the most flexible (and least specific) approach." },
                    { selector: "input[name~='data-username']", explanation: "Uses the tilde operator (`~=`), which matches a whole word in a space-separated list of values. This would work if the name value was 'data-username other', but fails on 'data-username' as one contiguous string." }
                ],
                trivia: "The `*=` operator is the 'contains' attribute selector, which looks for the specified substring anywhere within the attribute's value. This is powerful when dealing with dynamic or auto-generated attributes.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors",
                html: `
                    <input type="text" name="data-email" placeholder="Email">
                    <input type="text" name="data-username" placeholder="Username">
                    <input type="text" name="data-pass" placeholder="Password">
                `
            },
            {
                id: 8,
                prompt: "Target the third item in the list, regardless of its tag name, using :nth-child.",
                targetSelector: "li:nth-child(3)",
                type: "Structural Pseudo-class (:nth-child)",
                alternatives: [
                    { selector: "ol li:nth-child(3)", explanation: "More specific by scoping the selection to `li` elements inside an ordered list (`ol`). This is generally safer than using just the pseudo-class alone." },
                    { selector: "li:nth-of-type(3)", explanation: "This selects the third item *of its type* (the third `li` element) among its siblings. It works here because all siblings are list items." }
                ],
                trivia: "`:nth-child(n)` counts elements based on their position among *all* siblings, regardless of tag name. It is commonly used for things like zebra-striping rows in a table (`:nth-child(odd)`).",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-child",
                html: `
                    <ol>
                        <li>First Item</li>
                        <li>Second Item</li>
                        <li>Third Item</li>
                        <li>Fourth Item</li>
                    </ol>
                `
            },
            {
                id: 9,
                prompt: "Target the Save button which does not have the class .disabled.",
                targetSelector: "button:not(.disabled)",
                type: "Negation Pseudo-class (:not)",
                alternatives: [
                    { selector: ".btn-save:not(.disabled)", explanation: "This targets any element with the class `.btn-save` that is not disabled. This is less specific but often clearer when writing component-based CSS." },
                    { selector: "button.btn-save:not(.disabled)", explanation: "The most specific option. Combines tag name, class name, and the negation pseudo-class, clearly defining the exact criteria." }
                ],
                trivia: "The Negation Pseudo-class (`:not`) is often called the 'structural pseudo-class.' It is non-inclusive, meaning styles applied by it cannot be overridden by other styles of the same specificity *if* the negation is the only difference.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/:not",
                html: `
                    <button class="btn-save disabled">Save (Disabled)</button>
                    <button class="btn-save">Save (Enabled)</button>
                    <button class="btn-cancel">Cancel</button>
                `
            },
            {
                id: 10,
                prompt: "Target the checkbox that is currently checked.",
                targetSelector: "input:checked",
                type: "UI State Pseudo-class (:checked)",
                alternatives: [
                    { selector: "input[type='checkbox']:checked", explanation: "This adds the attribute selector for `type='checkbox'`, ensuring the selector only applies to checkbox inputs, not radio buttons or other checked inputs." }
                ],
                trivia: "The UI State Pseudo-class (`:checked`) selects radio buttons or checkboxes that are currently selected. You often use the Adjacent Sibling Combinator (`+`) to style a custom label based on the checked state.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/:checked",
                html: `
                    <label>
                        <input type="checkbox"> Unchecked
                    </label>
                    <label>
                        <input type="checkbox" checked> Checked
                    </label>
                `
            },
        ];

        // --- CORE STATE MANAGEMENT & INITIALIZATION (JS functions below) ---
        
        function initializeChallenges() {
            const container = document.getElementById('all-challenges');
            let htmlContent = '';

            challengeDefinitions.forEach(def => {
                challengeStates[def.id] = {
                    id: def.id,
                    attempts: 0,
                    isSolved: false,
                    isRevealed: false,
                    correctTarget: def.targetSelector,
                    baseHTML: def.html,
                    currentHTML: def.html,
                    successfulSelectors: [],
                };

                htmlContent += `
                    <div id="challenge-${def.id}" class="challenge-container">
                        <div class="challenge-header">
                            <h3 id="challenge-title-${def.id}">Challenge ${def.id}</h3>
                            <span id="status-${def.id}" style="color: grey;">(Unsolved)</span>
                        </div>
                        <p id="prompt-${def.id}">${def.prompt}</p>
                        
                        <div id="target-area-${def.id}" class="challenge-target-area">
                            ${def.html}
                        </div>
                        
                        <div class="challenge-ui">
                            <input type="text" id="selector-input-${def.id}" placeholder="Enter your selector
