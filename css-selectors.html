<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Ultimate CSS Selector Lab</title>
    <link rel="stylesheet" href="styles.css"> 
    <style>
        /* Existing Global Styles from previous response (omitted for brevity) */
        
        .container {
            /* Adjust container for full-width main content, if necessary */
            max-width: 1200px;
            margin: 0 auto;
        }

        .main-content {
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .challenge-container {
            margin-top: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 6px;
            margin-bottom: 30px;
            background-color: #f9f9f9;
        }
        
        .challenge-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        .challenge-header h3 {
            margin: 0;
            color: #333;
        }
        
        /* The area containing the elements to be inspected */
        .challenge-target-area {
            padding: 15px;
            border: 2px dashed #a0c3e8;
            background-color: #eaf2fa;
            margin-bottom: 15px;
            text-align: center;
        }

        /* Styling for the Target Element (Hidden from the user, used by JS) */
        .target-highlight {
            border: 2px solid #ff0000; /* Red border to visually identify the target */
            display: inline-block;
            padding: 3px;
            margin: 2px;
            background-color: #ffffe0; /* Light yellow background */
            transition: all 0.2s ease;
        }

        /* The actual user interface elements */
        .challenge-ui {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .challenge-ui input[type="text"] {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
        }

        .challenge-ui button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .challenge-ui button:hover {
            background-color: #0056b3;
        }
        
        .validation-feedback {
            padding: 10px;
            border-radius: 4px;
            min-height: 40px; 
            margin-top: 10px;
        }

        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .info {
            background-color: #e2f4fb;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        /* Utility class to visually reset the element after validation/reset */
        .visually-reset {
            border: none !important;
            background-color: transparent !important;
            padding: 0 !important;
            margin: 0 !important;
        }

        .reveal-button {
            background-color: #ffc107;
            color: #333;
            margin-top: 10px;
        }
    </style>
</head>
<body>

    <header class="navbar">...</header>
    <div class="container">
        <main class="content main-content">
            <h1>The Ultimate CSS Selector Lab 🎯</h1>
            <p>Your task: Write a selector that targets **only the element currently highlighted with the red border and yellow background** within each challenge box. You must remove all other highlighting by validating correctly.</p>
            
            <div id="all-challenges">
                </div>
            
        </main>
    </div>
    <footer>...</footer>

    <script>
        // Store the state of each challenge
        const challengeStates = [];

        // Definition of all challenges
        const challengeDefinitions = [
            // Note: The HTML should use generic attributes to force users to use the selector logic.
            // The "correct" element is the one that temporarily has the 'target-highlight' class applied in JS.
            {
                id: 1,
                title: "Simple ID Selector",
                prompt: "Target the **Primary Login Button** using its unique ID.",
                targetSelector: "#login-primary",
                type: "ID Selector",
                alternatives: ["button#login-primary", "section > button#login-primary"],
                trivia: "The ID selector is the most powerful in terms of specificity (100 points), often used for main layout elements, but is generally avoided in component-based CSS.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors",
                html: `
                    <button id="login-primary" class="btn btn-primary">Primary Login Button</button>
                    <button id="login-secondary" class="btn btn-secondary">Secondary Button</button>
                `
            },
            {
                id: 2,
                title: "Class Selector",
                prompt: "Target the item marked **Urgent** using its class.",
                targetSelector: ".task-urgent",
                type: "Class Selector",
                alternatives: ["li.task-urgent", "ul > .task-urgent"],
                trivia: "Classes are the backbone of modern CSS. An element can have multiple classes, but only one ID.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors",
                html: `
                    <ul>
                        <li class="task-default">Normal Item</li>
                        <li class="task-urgent">Urgent Item</li>
                        <li class="task-default">Another Normal Item</li>
                    </ul>
                `
            },
            {
                id: 3,
                title: "Descendant Combinator (Space)",
                prompt: "Target the **Save** button that is contained *anywhere* inside the `#settings-modal`.",
                targetSelector: "#settings-modal .btn-save",
                type: "Descendant Combinator",
                alternatives: ["#settings-modal button.btn-save", "div#settings-modal button.btn-save"],
                trivia: "A single space is the oldest and most common combinator, selecting elements nested at any depth.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/Descendant_combinator",
                html: `
                    <div id="settings-modal" style="padding: 10px; border: 1px solid #ccc;">
                        <button class="btn-cancel">Cancel</button>
                        <div class="footer">
                            <button class="btn-save">Save</button>
                        </div>
                    </div>
                `
            },
            {
                id: 4,
                title: "Child Combinator (>)",
                prompt: "Target the **Title** text that is a **direct child** of the `.card-header`.",
                targetSelector: ".card-header > h2",
                type: "Child Combinator",
                alternatives: [".card > .card-header > h2", ".card-header > *"],
                trivia: "The Child Combinator `>` is often used for performance and preventing deeply nested styles from unintentionally affecting elements.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/Child_combinator",
                html: `
                    <div class="card" style="border: 1px solid #ccc; padding: 10px;">
                        <div class="card-header">
                            <h2>Card Title</h2>
                            <span>
                                <h2>Nested Title (Not Target)</h2>
                            </span>
                        </div>
                        <p>Card Body</p>
                    </div>
                `
            },
            {
                id: 5,
                title: "Adjacent Sibling Combinator (+)",
                prompt: "Target the **Second Item** that immediately follows the element with the class `.first-element`.",
                targetSelector: ".first-element + li",
                type: "Adjacent Sibling Combinator",
                alternatives: [".first-element + *"],
                trivia: "The Adjacent Sibling Combinator `+` can only select one element: the very next one.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/Adjacent_sibling_combinator",
                html: `
                    <ul>
                        <li class="list-item">Zero Item</li>
                        <li class="list-item first-element">First Item</li>
                        <li class="list-item second-element">Second Item</li>
                        <li class="list-item">Third Item</li>
                    </ul>
                `
            },
            {
                id: 6,
                title: "General Sibling Combinator (~)",
                prompt: "Target the **Comments** button, which appears somewhere after the `h3` element.",
                targetSelector: "h3 ~ button.comments",
                type: "General Sibling Combinator",
                alternatives: ["h3 ~ .comments", "div > h3 ~ button"],
                trivia: "The General Sibling Combinator `~` selects all siblings that follow the first element, making it ideal for styling subsequent content.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/General_sibling_combinator",
                html: `
                    <button class="share">Share</button>
                    <h3>Post Title</h3>
                    <p>Post content...</p>
                    <button class="like">Like</button>
                    <button class="comments">Comments</button>
                `
            },
            {
                id: 7,
                title: "Attribute Selector (Contains)",
                prompt: "Target the input field whose `name` attribute contains the word **'user'**.",
                targetSelector: "input[name*='user']",
                type: "Attribute Selector (Substring Match)",
                alternatives: ["*[name*='user']"],
                trivia: "The `*=` operator is incredibly useful for finding elements based on partial string matches, perfect for dynamic or generated attributes.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors",
                html: `
                    <input type="text" name="data-email" placeholder="Email">
                    <input type="text" name="data-username" placeholder="Username">
                    <input type="text" name="data-pass" placeholder="Password">
                `
            },
            {
                id: 8,
                title: "Structural Pseudo-class (:nth-child)",
                prompt: "Target the **third item** in the list, regardless of its tag name, using **:nth-child**.",
                targetSelector: ":nth-child(3)",
                type: "Structural Pseudo-class (:nth-child)",
                alternatives: ["li:nth-child(3)", "*:nth-child(3)"],
                trivia: "`:nth-child(2n+1)` is a common formula to select all odd-numbered elements.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-child",
                html: `
                    <ol>
                        <li>First Item</li>
                        <li>Second Item</li>
                        <li>Third Item</li>
                        <li>Fourth Item</li>
                    </ol>
                `
            },
            {
                id: 9,
                title: "Negation Pseudo-class (:not)",
                prompt: "Target the **Save** button which **does not** have the class `.disabled`.",
                targetSelector: "button:not(.disabled)",
                type: "Negation Pseudo-class (:not)",
                alternatives: ["button:not([disabled])", "button.btn-save:not(.disabled)"],
                trivia: "`:not()` can take any simple selector as an argument, but cannot be nested (e.g., `:not(:not(div))` is invalid).",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/:not",
                html: `
                    <button class="btn-save disabled">Save (Disabled)</button>
                    <button class="btn-save">Save (Enabled)</button>
                    <button class="btn-cancel">Cancel</button>
                `
            },
            {
                id: 10,
                title: "UI State Pseudo-class (:checked)",
                prompt: "Target the **checkbox** that is currently **checked**.",
                targetSelector: "input:checked",
                type: "UI State Pseudo-class (:checked)",
                alternatives: ["input[type='checkbox']:checked"],
                trivia: "`:checked` applies to radio buttons and checkboxes. You can't style the checkbox itself very well, but you can style its label using the adjacent sibling selector (+).",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/:checked",
                html: `
                    <label>
                        <input type="checkbox"> Unchecked
                    </label>
                    <label>
                        <input type="checkbox" checked> Checked
                    </label>
                `
            },
        ];

        // --- CORE STATE MANAGEMENT & INITIALIZATION ---
        
        /**
         * Initializes the challenge states and renders all challenges to the DOM.
         */
        function initializeChallenges() {
            const container = document.getElementById('all-challenges');
            let htmlContent = '';

            challengeDefinitions.forEach(def => {
                // Initialize state for each challenge
                challengeStates[def.id] = {
                    id: def.id,
                    attempts: 0,
                    isSolved: false,
                    isRevealed: false,
                    correctTarget: def.targetSelector,
                    baseHTML: def.html,
                    currentHTML: def.html // Use base HTML initially
                };

                // Build the HTML structure for each challenge box
                htmlContent += `
                    <div id="challenge-${def.id}" class="challenge-container">
                        <div class="challenge-header">
                            <h3 id="challenge-title-${def.id}">Challenge ${def.id}: ${def.title}</h3>
                            <span id="status-${def.id}" style="color: grey;">(Unsolved)</span>
                        </div>
                        <p id="prompt-${def.id}">${def.prompt}</p>
                        <div id="target-area-${def.id}" class="challenge-target-area">
                            ${def.html}
                        </div>
                        <div class="challenge-ui">
                            <input type="text" id="selector-input-${def.id}" placeholder="Enter your selector here (e.g., #my-id)" data-id="${def.id}">
                            <button onclick="validateChallenge(${def.id})">Validate</button>
                        </div>
                        <div id="feedback-${def.id}" class="validation-feedback"></div>
                    </div>
                `;
            });

            container.innerHTML = htmlContent;
            
            // Apply initial highlighting after rendering
            challengeDefinitions.forEach(def => applyHighlighting(def.id));
        }

        /**
         * Applies the 'target-highlight' class to the correct element in the DOM.
         */
        function applyHighlighting(challengeId) {
            const state = challengeStates[challengeId];
            if (state.isSolved) return;

            const targetArea = document.getElementById(`target-area-${challengeId}`);
            if (!targetArea) return;

            try {
                // Remove existing highlights first
                targetArea.querySelectorAll('.target-highlight').forEach(el => {
                    el.classList.remove('target-highlight');
                    el.classList.add('visually-reset'); // Apply temporary reset styles
                    // Remove reset class after a short delay to ensure clean look
                    setTimeout(() => el.classList.remove('visually-reset'), 50);
                });

                // Find and apply new highlight
                const targetElement = targetArea.querySelector(state.correctTarget);
                if (targetElement) {
                    targetElement.classList.add('target-highlight');
                }
            } catch (e) {
                console.error(`Error highlighting target for challenge ${challengeId}: ${e.message}`);
            }
        }

        /**
         * Cleans up the visual target highlight upon successful validation.
         */
        function removeHighlighting(challengeId) {
            const targetArea = document.getElementById(`target-area-${challengeId}`);
            if (targetArea) {
                targetArea.querySelectorAll('.target-highlight').forEach(el => {
                    el.classList.remove('target-highlight');
                    el.style.border = 'none'; // Ensure all borders are removed
                    el.style.backgroundColor = 'transparent';
                    el.style.padding = '0';
                    el.style.margin = '0';
                });
            }
        }

        // --- CORE VALIDATION LOGIC ---

        function validateChallenge(challengeId) {
            const state = challengeStates[challengeId];
            if (state.isSolved) return;

            const inputField = document.getElementById(`selector-input-${challengeId}`);
            const feedbackElement = document.getElementById(`feedback-${challengeId}`);
            const userInput = inputField.value.trim();

            feedbackElement.className = 'validation-feedback';

            if (userInput === '') {
                feedbackElement.textContent = 'Please enter a selector to validate.';
                feedbackElement.classList.add('error');
                return;
            }

            try {
                // 1. Get the single, true target element from the DOM
                const targetArea = document.getElementById(`target-area-${challengeId}`);
                const correctTarget = targetArea.querySelector(state.correctTarget);

                // 2. Get the elements selected by the user's input
                const selectedElements = targetArea.querySelectorAll(userInput);

                if (!correctTarget) {
                    feedbackElement.textContent = 'Internal Error: Target element missing.';
                    feedbackElement.classList.add('error');
                    return;
                }
                
                // Check if the user's selection contains *only* the correct target element.
                // Stricter validation: must select exactly 1 element AND it must be the target.
                const isCorrect = selectedElements.length === 1 && selectedElements[0] === correctTarget;

                if (isCorrect) {
                    handleSuccess(challengeId, userInput);
                } else {
                    handleFailure(challengeId, userInput, selectedElements.length, correctTarget);
                }

            } catch (e) {
                // Invalid CSS selector syntax
                feedbackElement.textContent = `🚫 Syntax Error: "${userInput}" is not a valid CSS selector. Check for typos or invalid characters.`;
                feedbackElement.classList.add('error');
            }
        }
        
        // --- SUCCESS AND FAILURE HANDLERS ---

        function handleSuccess(challengeId, correctSelector) {
            const state = challengeStates[challengeId];
            const feedbackElement = document.getElementById(`feedback-${challengeId}`);
            const statusElement = document.getElementById(`status-${challengeId}`);
            const challengeDef = challengeDefinitions.find(d => d.id === challengeId);

            state.isSolved = true;
            statusElement.textContent = "(Solved)";
            statusElement.style.color = '#155724';
            
            removeHighlighting(challengeId);
            
            let alternativesHtml = '';
            challengeDef.alternatives.forEach(alt => {
                // Only show alternatives that aren't the user's answer
                if (alt !== correctSelector) {
                    alternativesHtml += `<li><code>${alt}</code></li>`;
                }
            });

            feedbackElement.classList.add('success');
            feedbackElement.innerHTML = `
                🎉 **SUCCESS!** You correctly targeted the element with <code>${correctSelector}</code>.
                <br><br>
                **Lesson Learned: ${challengeDef.type}** 💡
                <p>${challengeDef.trivia}</p>
                <p>Did you know you could also use these selectors?
                    <ul>
                        ${alternativesHtml}
                    </ul>
                </p>
                <a href="${challengeDef.learnMore}" target="_blank" style="text-decoration: none;">
                    <button class="btn btn-primary">📚 Learn More: ${challengeDef.type}</button>
                </a>
            `;
        }
        
        function handleFailure(challengeId, userInput, count, correctTarget) {
            const state = challengeStates[challengeId];
            const feedbackElement = document.getElementById(`feedback-${challengeId}`);
            const challengeDef = challengeDefinitions.find(d => d.id === challengeId);
            state.attempts++;

            let message = '';
            feedbackElement.classList.add('error');
            
            // Check if user selected too many elements (not strict enough)
            if (count > 0 && Array.from(document.querySelectorAll(`#target-area-${challengeId} ${userInput}`)).includes(correctTarget)) {
                 message = `❌ Close! Your selector selected ${count} element(s), including the target. Try to be more specific and select *only* the highlighted element.`;
            } else if (count > 0) {
                 message = `❌ Incorrect. Your selector selected ${count} element(s), but none of them are the highlighted target. Inspect the target's attributes carefully!`;
            } else {
                 message = `❌ Incorrect. The selector "${userInput}" selected no elements. Double-check your syntax and the target's ID/class names.`;
            }


            // --- Progressive Hint System ---
            if (state.attempts === 2) {
                // Hint 2: Give the type of selector
                message += `<br><br>🚨 **Hint 2:** The type of selector you need to use here is a **${challengeDef.type}**.`;
                feedbackElement.classList.remove('error');
                feedbackElement.classList.add('info');
            } else if (state.attempts === 3) {
                // Hint 3: More instructional, focusing on a key attribute
                const keyAttr = (state.correctTarget.includes('#') ? 'ID' : state.correctTarget.includes('.') ? 'CLASS' : 'TAG');
                message += `<br><br>💡 **Hint 3:** You need to combine the ${keyAttr} of the target element with a **Combinator** or **Pseudo-class**.`;
                feedbackElement.classList.remove('error');
                feedbackElement.classList.add('info');
            } else if (state.attempts === 4) {
                // Hint 4: Give the necessary operator/combinator
                const hintType = challengeDef.type.includes('Combinator') ? 'Combinator' : 'Pseudo-class';
                message += `<br><br>🧠 **Hint 4 (Deep Dive):** Focus on the relationship between the target and its parent/sibling. You will need a **${hintType}**.`;
                feedbackElement.classList.remove('error');
                feedbackElement.classList.add('info');
            } else if (state.attempts >= 5 && !state.isRevealed) {
                // Hint 5: Offer to reveal the solution and create a new challenge
                message += `<br><br>🛑 **5 Failed Attempts.** Would you like to reveal the solution for this specific challenge and then try a new, similar challenge to ensure the lesson sticks?
                    <button class="reveal-button" onclick="revealSolution(${challengeId})">Yes, Reveal Solution & Try New Challenge</button>`;
                feedbackElement.classList.remove('error');
                feedbackElement.classList.add('error'); // Back to error color for attention
            }
            
            feedbackElement.innerHTML = message;
        }

        function revealSolution(challengeId) {
            const state = challengeStates[challengeId];
            const feedbackElement = document.getElementById(`feedback-${challengeId}`);
            const inputField = document.getElementById(`selector-input-${challengeId}`);
            const challengeDef = challengeDefinitions.find(d => d.id === challengeId);

            state.isRevealed = true;
            inputField.value = state.correctTarget; // Show the answer
            
            // Success message with the answer
            feedbackElement.classList.remove('error');
            feedbackElement.classList.add('success');
            feedbackElement.innerHTML = `
                ✅ **Solution Revealed:** The correct selector was <code>${state.correctTarget}</code>.
                <br>
                Please study the lesson below and then click the button to try a new related challenge!
                <a href="${challengeDef.learnMore}" target="_blank" style="text-decoration: none;"><button class="btn btn-primary" style="margin-top: 5px;">📚 Learn More: ${challengeDef.type}</button></a>
                <button class="reveal-button" onclick="resetChallenge(${challengeId})">🔄 Try New ${challengeDef.type} Challenge</button>
            `;
            removeHighlighting(challengeId);
        }

        // --- DOM MANIPULATION FOR REVEALED CHALLENGE ---
        
        function resetChallenge(challengeId) {
            const state = challengeStates[challengeId];
            const challengeDef = challengeDefinitions.find(d => d.id === challengeId);
            const targetArea = document.getElementById(`target-area-${challengeId}`);
            const inputField = document.getElementById(`selector-input-${challengeId}`);
            const feedbackElement = document.getElementById(`feedback-${challengeId}`);
            
            // Create a completely new, but related, challenge HTML structure
            const newHtml = generateNewChallengeHTML(challengeDef);
            
            // Update state with new target (we'll assume the new target is the first element with the 'new-target' class)
            state.correctTarget = '.new-target';
            state.attempts = 0;
            state.isRevealed = false;
            state.isSolved = false;
            
            targetArea.innerHTML = newHtml;
            inputField.value = '';
            feedbackElement.className = 'validation-feedback';
            feedbackElement.innerHTML = `🌟 **New Challenge!** Try to apply the **${challengeDef.type}** logic you just learned!`;

            // Apply highlighting to the new target
            applyHighlighting(challengeId);
        }

        // Simplistic function to generate a new, but similar, challenge (required for the reveal mechanic)
        function generateNewChallengeHTML(def) {
            // This is a placeholder. For a real app, you'd have a pool of HTML snippets per type.
            // Here, we just modify the IDs/Classes slightly and change the prompt to avoid caching the selector.
            let newPrompt = def.prompt.replace('Target', 'Find').replace('Button', 'Link').replace('item', 'div');
            document.getElementById(`prompt-${def.id}`).textContent = newPrompt;
            
            if (def.type.includes('ID')) {
                return `
                    <a id="link-one">Link 1</a>
                    <a id="new-target" class="new-target">Link 2 (Target)</a>
                    <a id="link-three">Link 3</a>
                `;
            } else if (def.type.includes('Class')) {
                return `
                    <div class="box-regular">Box A</div>
                    <div class="box-vip new-target">Box B (Target)</div>
                    <div class="box-regular">Box C</div>
                `;
            }
            // Fallback for others - simple structure swap
            return def.html.replace(def.targetSelector, '.new-target').replace(def.targetSelector, '.new-target');
        }

        // Run the initialization function
        document.addEventListener('DOMContentLoaded', initializeChallenges);
    </script>

</body>
</html>
