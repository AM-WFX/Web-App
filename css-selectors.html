<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Ultimate CSS Selector Lab</title>
    <link rel="stylesheet" href="styles.css"> 
    
    <style>
        /* --- General Layout and Formatting --- */
        .container {
            max-width: 1200px; 
            margin: 0 auto;
        }

        .main-content {
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* --- Individual Challenge Box --- */
        .challenge-container {
            margin-top: 30px;
            padding: 20px;
            border: 1px solid #c9e6ff;
            border-radius: 6px;
            margin-bottom: 30px;
            background-color: #f6faff;
        }
        
        .challenge-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 2px solid #e0efff;
            padding-bottom: 10px;
        }

        .challenge-header h3 {
            margin: 0;
            color: #1a5c9a;
        }
        
        /* The area containing the elements to be inspected */
        .challenge-target-area {
            padding: 15px;
            border: 2px dashed #a0c3e8;
            background-color: #eaf2fa;
            margin-bottom: 15px;
            text-align: center;
        }
        
        /* The Visual Target Highlight (Applied by JS) */
        .target-highlight {
            border: 2px solid #cc0000 !important;
            background-color: #fffac9 !important;
            display: inline-block;
            padding: 3px;
            margin: 2px;
            transition: all 0.2s ease;
        }
        
        /* --- UI Elements --- */
        .challenge-ui {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .challenge-ui input[type="text"] {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
            font-size: 1em;
        }

        .challenge-ui button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            white-space: nowrap;
        }

        .challenge-ui button:hover {
            background-color: #0056b3;
        }
        
        /* --- Feedback Messages --- */
        .validation-feedback {
            padding: 15px;
            border-radius: 4px;
            min-height: 40px; 
            margin-top: 10px;
            line-height: 1.5;
        }

        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .info {
            background-color: #e2f4fb;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .hint-message {
            font-style: italic;
            margin-top: 10px;
        }

        /* --- Accordion/Dropdown Styling for Alternatives --- */
        .accordion {
            background-color: #eee;
            color: #444;
            cursor: pointer;
            padding: 10px;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 0.9em;
            transition: 0.4s;
            margin-top: 5px;
            border-radius: 4px;
        }

        .active-accordion, .accordion:hover {
            background-color: #ccc;
        }

        .panel {
            padding: 0 18px;
            background-color: white;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
            border-left: 2px solid #007bff;
            margin-bottom: 5px;
        }

        .reveal-button {
            background-color: #ffc107;
            color: #333;
            margin-top: 10px;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <header class="navbar">
        <div class="logo">My Site</div>
        <nav>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="about.html">About</a></li>
                <li><a href="css-selectors.html" class="active">Selectors</a></li>
            </ul>
        </nav>
    </header>

    <div class="container">
        <aside class="sidebar" style="/* Layout style here */">...</aside>
        
        <main class="content main-content">
            <h1>The Ultimate CSS Selector Lab ðŸŽ¯</h1>
            <p>Your task: Write a selector that targets **only the element currently highlighted** within each challenge box. You must remove the highlight by entering the correct selector and clicking 'Validate'.</p>
            
            <div id="all-challenges">
                </div>
            
        </main>
    </div>

    <footer>
        <p>&copy; 2025 My Awesome Website</p>
    </footer>

    <script>
        // Store the state of each challenge
        const challengeStates = {};
        
        // Helper function to create a new challenge structure (used after reveal)
        function generateNewChallengeHTML(def) {
            let html;
            let newTargetSelector;
            
            // Simple structure changes for different types
            if (def.type.includes('ID Selector')) {
                html = `
                    <button id="try-one" class="btn-group">Button One</button>
                    <button id="try-two" class="btn-group new-target">Target Again</button>
                    <button id="try-three" class="btn-group">Button Three</button>
                `;
                newTargetSelector = "#try-two";
            } else if (def.type.includes('Class Selector')) {
                html = `
                    <div class="data-item">Item A</div>
                    <div class="data-item new-target">Item B (Target)</div>
                    <div class="data-item">Item C</div>
                `;
                newTargetSelector = ".new-target";
            } else if (def.type.includes('Descendant Combinator')) {
                html = `
                    <div id="project-list">
                        <p>File A</p>
                        <div class="folder">
                            <p class="new-target">File B (Target)</p>
                        </div>
                    </div>
                `;
                newTargetSelector = "#project-list p.new-target";
            } else if (def.type.includes('Child Combinator')) {
                html = `
                    <ul class="nav-menu">
                        <li>Link 1</li>
                        <li><span>Link 2 (Not Target)</span></li>
                        <li class="new-target">Link 3 (Target)</li>
                    </ul>
                `;
                newTargetSelector = "ul.nav-menu > li.new-target";
            } else {
                 // Fallback for others - simple structure swap
                // This is a rough way to generate a new target, but works for the demo's needs
                html = def.baseHTML.replace(def.targetSelector.replace(/[#\.\s>+~:]/g, ''), 'new-target');
                newTargetSelector = def.correctTarget.replace(def.correctTarget.replace(/[#\.\s>+~:]/g, ''), 'new-target');
            }
            
            return { html: html, newTargetSelector: newTargetSelector };
        }

        // Definition of all challenges
        const challengeDefinitions = [
            {
                id: 1,
                prompt: "Target the Primary Login Button using its unique ID.",
                targetSelector: "#login-primary",
                type: "ID Selector",
                alternatives: [
                    { selector: "button#login-primary", explanation: "More specific by including the tag name, though redundant since IDs must be unique." },
                    { selector: "*#login-primary", explanation: "Uses the universal selector (*) with the ID. Also correct, but often less readable than just the ID." }
                ],
                trivia: "The ID selector is the most powerful in terms of specificity (100 points). It should be used for unique page elements.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors",
                html: `
                    <button id="login-primary" class="btn btn-primary">Primary Login Button</button>
                    <button id="login-secondary" class="btn btn-secondary">Secondary Button</button>
                `
            },
            {
                id: 2,
                prompt: "Target the item marked Urgent using its class.",
                targetSelector: ".task-urgent",
                type: "Class Selector",
                alternatives: [
                    { selector: "li.task-urgent", explanation: "Includes the tag name (li) which is often recommended for better scoping and readability." },
                    { selector: ".task-urgent.list-item", explanation: "Chains two class selectors. This increases specificity (20 points) and ensures both classes are present." }
                ],
                trivia: "Class selectors contribute 10 points to specificity. You can chain multiple classes without a space, like `.classA.classB`.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors",
                html: `
                    <ul>
                        <li class="list-item task-default">Normal Item</li>
                        <li class="list-item task-urgent">Urgent Item</li>
                        <li class="list-item task-default">Another Normal Item</li>
                    </ul>
                `
            },
            {
                id: 3,
                prompt: "Target the Save button that is contained *anywhere* inside the #settings-modal.",
                targetSelector: "#settings-modal .btn-save",
                type: "Descendant Combinator",
                alternatives: [
                    { selector: "#settings-modal button.btn-save", explanation: "More specific by including the tag name (button), preventing this style from leaking to a non-button element that might also have the class .btn-save." },
                    { selector: "div#settings-modal button.btn-save", explanation: "Most specific: combines tag name (div), ID (#settings-modal), and tag name (button) plus class (.btn-save)." }
                ],
                trivia: "A single space is the most common combinator, selecting elements nested at any depth. It's safe but can be slow if used on large DOM structures.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/Descendant_combinator",
                html: `
                    <div id="settings-modal" style="padding: 10px; border: 1px solid #ccc;">
                        <button class="btn-cancel">Cancel</button>
                        <div class="footer">
                            <button class="btn-save">Save</button>
                        </div>
                    </div>
                `
            },
            {
                id: 4,
                prompt: "Target the Title text that is a direct child of the .card-header.",
                targetSelector: ".card-header > h2",
                type: "Child Combinator",
                alternatives: [
                    { selector: ".card-header>h2", explanation: "Whitespace around the '>' is optional, but many prefer it for readability." },
                    { selector: ".card > .card-header > h2", explanation: "Uses multiple child combinators to ensure the hierarchy is strictly followed, which is highly performant." }
                ],
                trivia: "The Child Combinator `>` is often used for performance and preventing deeply nested styles from unintentionally affecting elements.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/Child_combinator",
                html: `
                    <div class="card" style="border: 1px solid #ccc; padding: 10px;">
                        <div class="card-header">
                            <h2>Card Title</h2>
                            <span>
                                <h2>Nested Title (Not Target)</h2>
                            </span>
                        </div>
                        <p>Card Body</p>
                    </div>
                `
            },
            {
                id: 5,
                prompt: "Target the Second Item that immediately follows the element with the class .first-element.",
                targetSelector: ".first-element + li",
                type: "Adjacent Sibling Combinator",
                alternatives: [
                    { selector: "li.first-element + li.list-item", explanation: "Highly specific, combining tag name and class for both the reference and the target element." },
                    { selector: ".first-element + *", explanation: "Uses the universal selector (*) to select the immediate sibling, regardless of its tag name." }
                ],
                trivia: "The Adjacent Sibling Combinator `+` can only select one element: the very next sibling. It's often used for clearing margins or adding spacing.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/Adjacent_sibling_combinator",
                html: `
                    <ul>
                        <li class="list-item">Zero Item</li>
                        <li class="list-item first-element">First Item</li>
                        <li class="list-item second-element">Second Item</li>
                        <li class="list-item">Third Item</li>
                    </ul>
                `
            },
            {
                id: 6,
                prompt: "Target the Comments button, which appears somewhere after the h3 element.",
                targetSelector: "h3 ~ button.comments",
                type: "General Sibling Combinator",
                alternatives: [
                    { selector: "h3 ~ .comments", explanation: "Less specific than the one provided, but correct if no other non-button element has the .comments class." },
                    { selector: "button.like ~ button.comments", explanation: "Uses two siblings to define the relationship, selecting the Comments button that follows the Like button." }
                ],
                trivia: "The General Sibling Combinator `~` selects all siblings that follow the first element, making it useful for applying styles to all elements after a specific one.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/General_sibling_combinator",
                html: `
                    <button class="share">Share</button>
                    <h3>Post Title</h3>
                    <p>Post content...</p>
                    <button class="like">Like</button>
                    <button class="comments">Comments</button>
                `
            },
            {
                id: 7,
                prompt: "Target the input field whose name attribute contains the word 'user'.",
                targetSelector: "input[name*='user']",
                type: "Attribute Selector (Substring Match)",
                alternatives: [
                    { selector: "*[name*='user']", explanation: "Uses the universal selector (*), selecting any element with the name attribute containing 'user'." },
                    { selector: "input[name~='data-username']", explanation: "Uses the tilde operator (~=) which matches a whole word in a space-separated list of values (would match if the attribute value was 'data-username other')." }
                ],
                trivia: "The `*=` operator is incredibly useful for finding elements based on partial string matches, perfect for dynamic or generated attributes.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors",
                html: `
                    <input type="text" name="data-email" placeholder="Email">
                    <input type="text" name="data-username" placeholder="Username">
                    <input type="text" name="data-pass" placeholder="Password">
                `
            },
            {
                id: 8,
                prompt: "Target the third item in the list, regardless of its tag name, using :nth-child.",
                targetSelector: "li:nth-child(3)",
                type: "Structural Pseudo-class (:nth-child)",
                alternatives: [
                    { selector: "ol li:nth-child(3)", explanation: "More specific by scoping the selection to li elements inside an ol (ordered list)." },
                    { selector: "li:nth-of-type(3)", explanation: "This would also work here because all siblings are list items, but :nth-of-type is safer when siblings have mixed tag names." }
                ],
                trivia: "`:nth-child` selects elements based on their position among all siblings, regardless of type. `:nth-of-type` selects based on position among siblings of the same tag name.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-child",
                html: `
                    <ol>
                        <li>First Item</li>
                        <li>Second Item</li>
                        <li>Third Item</li>
                        <li>Fourth Item</li>
                    </ol>
                `
            },
            {
                id: 9,
                prompt: "Target the Save button which does not have the class .disabled.",
                targetSelector: "button:not(.disabled)",
                type: "Negation Pseudo-class (:not)",
                alternatives: [
                    { selector: ".btn-save:not(.disabled)", explanation: "Selects elements with the class .btn-save that also don't have the class .disabled." },
                    { selector: "button.btn-save:not(.disabled)", explanation: "Even more specific, combining the tag and class with the negation." }
                ],
                trivia: "`:not()` can take any simple selector as an argument, but cannot be nested (e.g., `:not(:not(div))` is invalid in CSS Level 3).",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/:not",
                html: `
                    <button class="btn-save disabled">Save (Disabled)</button>
                    <button class="btn-save">Save (Enabled)</button>
                    <button class="btn-cancel">Cancel</button>
                `
            },
            {
                id: 10,
                prompt: "Target the checkbox that is currently checked.",
                targetSelector: "input:checked",
                type: "UI State Pseudo-class (:checked)",
                alternatives: [
                    { selector: "input[type='checkbox']:checked", explanation: "More specific, ensuring the element is both an input of type checkbox and is checked." }
                ],
                trivia: "`:checked` applies to radio buttons and checkboxes. You often use the adjacent sibling selector (`+`) to style the label or an associated element based on the checked state.",
                learnMore: "https://developer.mozilla.org/en-US/docs/Web/CSS/:checked",
                html: `
                    <label>
                        <input type="checkbox"> Unchecked
                    </label>
                    <label>
                        <input type="checkbox" checked> Checked
                    </label>
                `
            },
        ];

        // --- CORE STATE MANAGEMENT & INITIALIZATION ---
        
        function initializeChallenges() {
            const container = document.getElementById('all-challenges');
            let htmlContent = '';

            challengeDefinitions.forEach(def => {
                challengeStates[def.id] = {
                    id: def.id,
                    attempts: 0,
                    isSolved: false,
                    isRevealed: false,
                    correctTarget: def.targetSelector,
                    baseHTML: def.html,
                    currentHTML: def.html 
                };

                htmlContent += `
                    <div id="challenge-${def.id}" class="challenge-container">
                        <div class="challenge-header">
                            <h3 id="challenge-title-${def.id}">Challenge ${def.id}</h3>
                            <span id="status-${def.id}" style="color: grey;">(Unsolved)</span>
                        </div>
                        <p id="prompt-${def.id}">${def.prompt}</p>
                        
                        <div id="target-area-${def.id}" class="challenge-target-area">
                            ${def.html}
                        </div>
                        
                        <div class="challenge-ui">
                            <input type="text" id="selector-input-${def.id}" placeholder="Enter your selector here (e.g., .class-name)" data-id="${def.id}">
                            <button onclick="validateChallenge(${def.id})">Validate</button>
                        </div>
                        <div id="feedback-${def.id}" class="validation-feedback"></div>
                    </div>
                `;
            });

            container.innerHTML = htmlContent;
            challengeDefinitions.forEach(def => applyHighlighting(def.id));
        }

        function applyHighlighting(challengeId) {
            const state = challengeStates[challengeId];
            if (state.isSolved) return;

            const targetArea = document.getElementById(`target-area-${challengeId}`);
            if (!targetArea) return;

            try {
                targetArea.querySelectorAll('.target-highlight').forEach(el => el.classList.remove('target-highlight'));
                
                const targetElement = targetArea.querySelector(state.correctTarget);
                if (targetElement) {
                    targetElement.classList.add('target-highlight');
                }
            } catch (e) {
                console.error(`Error highlighting target for challenge ${challengeId}: ${e.message}`);
            }
        }

        function removeHighlighting(challengeId) {
            const targetArea = document.getElementById(`target-area-${challengeId}`);
            if (targetArea) {
                targetArea.querySelectorAll('.target-highlight').forEach(el => el.classList.remove('target-highlight'));
            }
        }

        // --- CORE VALIDATION LOGIC ---
        
        function toggleAccordion(button) {
            button.classList.toggle("active-accordion");
            let panel = button.nextElementSibling;
            if (panel.style.maxHeight) {
                panel.style.maxHeight = null;
            } else {
                // Set max-height to scrollHeight plus a buffer (100px) to ensure content is visible
                panel.style.maxHeight = panel.scrollHeight + 100 + "px";
            } 
        }

        function validateChallenge(challengeId) {
            const state = challengeStates[challengeId];
            const inputField = document.getElementById(`selector-input-${challengeId}`);
            const feedbackElement = document.getElementById(`feedback-${challengeId}`);
            const userInput = inputField.value.trim();

            feedbackElement.className = 'validation-feedback';

            if (userInput === '') {
                feedbackElement.textContent = 'Please enter a selector to validate.';
                feedbackElement.classList.add('error');
                return;
            }

            try {
                const targetArea = document.getElementById(`target-area-${challengeId}`);
                const correctTarget = targetArea.querySelector(state.correctTarget);
                const selectedElements = targetArea.querySelectorAll(userInput);

                if (!correctTarget) {
                    feedbackElement.textContent = 'Internal Error: Target element missing.';
                    feedbackElement.classList.add('error');
                    return;
                }
                
                // Stricter validation: must select exactly 1 element AND it must be the target.
                const isCorrect = selectedElements.length === 1 && selectedElements[0] === correctTarget;

                if (isCorrect) {
                    handleSuccess(challengeId, userInput);
                } else {
                    handleFailure(challengeId, userInput, selectedElements, correctTarget);
                }

            } catch (e) {
                // Invalid CSS selector syntax
                feedbackElement.textContent = `ðŸš« Syntax Error: "${userInput}" is not a valid CSS selector. Check for typos or invalid characters.`;
                feedbackElement.classList.add('error');
            }
        }
        
        // --- SUCCESS AND FAILURE HANDLERS ---

        function handleSuccess(challengeId, correctSelector) {
            const state = challengeStates[challengeId];
            const feedbackElement = document.getElementById(`feedback-${challengeId}`);
            const statusElement = document.getElementById(`status-${challengeId}`);
            const challengeDef = challengeDefinitions.find(d => d.id === challengeId);
            
            // Only update status and remove highlight if it's the first time solved
            if (!state.isSolved) {
                statusElement.textContent = "(SOLVED!)";
                statusElement.style.color = '#155724';
                removeHighlighting(challengeId);
            }

            state.isSolved = true;
            
            // Build alternatives list with accordions/dropdowns
            const alternativesHtml = challengeDef.alternatives
                .filter(alt => alt.selector.toLowerCase().trim() !== correctSelector.toLowerCase().trim())
                .map((alt, index) => `
                    <button class="accordion" onclick="toggleAccordion(this)">
                        Alternative ${index + 1}: <code>${alt.selector}</code>
                    </button>
                    <div class="panel">
                        <p><strong>Why it works:</strong> ${alt.explanation}</p>
                    </div>
                `).join('');

            feedbackElement.classList.add('success');
            feedbackElement.innerHTML = `
                ðŸŽ‰ **PERFECT!** You successfully targeted the element with <code>${correctSelector}</code>.
                <br><br>
                <strong>Lesson Learned: ${challengeDef.type}</strong> ðŸ’¡
                <div class="hint-message">${challengeDef.trivia}</div>
                
                <p>Explore other ways to solve this challenge:</p>
                ${alternativesHtml}
            `;
            
            // Clear attempts counter on success
            state.attempts = 0;
        }
        
        function handleFailure(challengeId, userInput, selectedElements, correctTarget) {
            const state = challengeStates[challengeId];
            const feedbackElement = document.getElementById(`feedback-${challengeId}`);
            const challengeDef = challengeDefinitions.find(d => d.id === challengeId);
            state.attempts++;

            let message = '';
            feedbackElement.classList.add('error');
            
            // Progressive Hint System
            if (state.attempts === 1) {
                let nudge;
                if (selectedElements.length === 0) {
                    nudge = `Incorrect. Your selector selected **no elements**. Check your basic syntax (e.g., did you miss a '.' or '#')?`;
                } else if (Array.from(selectedElements).includes(correctTarget)) {
                    nudge = `Close! Your selector selected **${selectedElements.length} elements**, including the target. Try to be more specific to select *only* the target.`;
                } else {
                    nudge = `Incorrect. Your selector selected **${selectedElements.length} element(s)**, but the target was not among them. Check the attributes of the highlighted element!`;
                }
                message = `${nudge}`;
            } 
            
            else if (state.attempts === 2) {
                message = `Still incorrect. 
                    <br><div class="hint-message info">ðŸš¨ **Hint 2:** The type of selector you need to master here is a **${challengeDef.type}**. Focus your learning on that concept!</div>`;
                feedbackElement.classList.remove('error');
                feedbackElement.classList.add('info');
            } 
            
            else if (state.attempts === 3) {
                const hintType = challengeDef.type.includes('Combinator') ? 'Combinator' : challengeDef.type.includes('Pseudo') ? 'Pseudo-class' : 'Attribute Selector';
                message = `Three strikes. 
                    <br><div class="hint-message info">ðŸ’¡ **Hint 3:** This challenge requires a **${hintType}**. Look for relationships (parent/sibling) or a specific state (checked/disabled) in the HTML structure.</div>`;
                feedbackElement.classList.remove('error');
                feedbackElement.classList.add('info');
            } 
            
            else if (state.attempts === 4) {
                let operatorHint = '';
                if (challengeDef.type.includes('Descendant')) operatorHint = 'Use a **space** between selectors.';
                else if (challengeDef.type.includes('Child')) operatorHint = 'Use the **>** operator.';
                else if (challengeDef.type.includes('Adjacent')) operatorHint = 'Use the **+** operator.';
                else if (challengeDef.type.includes('General')) operatorHint = 'Use the **~** operator.';
                else if (challengeDef.type.includes('Attribute')) operatorHint = 'Use brackets **[ ]** and an operator like **[*=]**.';
                else if (challengeDef.type.includes('Pseudo')) operatorHint = 'Use the colon **:** followed by the selector name.';
                
                message = `Final attempt nudge. 
                    <br><div class="hint-message info">ðŸ§  **Hint 4 (Deep Dive):** ${operatorHint}</div>`;
                feedbackElement.classList.remove('error');
                feedbackElement.classList.add('info');
            } 
            
            else if (state.attempts >= 5 && !state.isRevealed) {
                message = `ðŸ›‘ **5 Failed Attempts.** It's time to learn! Would you like to reveal the solution for this specific challenge and then immediately try a new, related challenge to ensure the lesson sticks?
                    <br><button class="reveal-button" onclick="revealSolution(${challengeId})">Yes, Reveal Solution & Try New Challenge</button>`;
                feedbackElement.classList.remove('info');
                feedbackElement.classList.add('error');
            }
            
            feedbackElement.innerHTML = message;
        }

        function revealSolution(challengeId) {
            const state = challengeStates[challengeId];
            const feedbackElement = document.getElementById(`feedback-${challengeId}`);
            const inputField = document.getElementById(`selector-input-${challengeId}`);
            const challengeDef = challengeDefinitions.find(d => d.id === challengeId);
            const statusElement = document.getElementById(`status-${challengeId}`);

            state.isRevealed = true;
            statusElement.textContent = "(Solution Revealed)";
            inputField.value = state.correctTarget; // Show the answer
            
            feedbackElement.classList.remove('error', 'info');
            feedbackElement.classList.add('success');
            feedbackElement.innerHTML = `
                âœ… **Solution Revealed:** The correct selector was <code>${state.correctTarget}</code>.
                <br>
                <p style="margin-top: 10px;">Please study the solution, then click the button below to solidify your understanding with a **fresh challenge** of the same selector type.</p>
                <button class="accordion" style="background-color: #007bff; color: white; margin-right: 5px;" onclick="resetChallenge(${challengeId})">ðŸ”„ Try New ${challengeDef.type} Challenge</button>
            `;
            removeHighlighting(challengeId);
        }

        function resetChallenge(challengeId) {
            const state = challengeStates[challengeId];
            const challengeDef = challengeDefinitions.find(d => d.id === challengeId);
            const targetArea = document.getElementById(`target-area-${challengeId}`);
            const inputField = document.getElementById(`selector-input-${challengeId}`);
            const feedbackElement = document.getElementById(`feedback-${challengeId}`);
            const statusElement = document.getElementById(`status-${challengeId}`);
            
            const { html: newHtml, newTargetSelector: newTarget } = generateNewChallengeHTML(challengeDef);
            
            state.correctTarget = newTarget;
            state.attempts = 0;
            state.isRevealed = false;
            state.isSolved = false;
            
            targetArea.innerHTML = newHtml;
            inputField.value = '';
            inputField.disabled = false;
            inputField.nextElementSibling.disabled = false;
            feedbackElement.className = 'validation-feedback';
            feedbackElement.innerHTML = `ðŸŒŸ **New Challenge!** Apply the **${challengeDef.type}** logic to this new structure.`;
            statusElement.textContent = "(Unsolved)";
            statusElement.style.color = 'grey';

            applyHighlighting(challengeId);
        }

        // Run the initialization function when the page loads
        document.addEventListener('DOMContentLoaded', initializeChallenges);
    </script>

</body>
</html>
